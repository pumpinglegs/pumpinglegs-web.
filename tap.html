import asyncio
import logging
import json
import time
import aiosqlite
import aiohttp
from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import Command
from aiogram.types import (
    WebAppInfo,
    InlineKeyboardMarkup,
    InlineKeyboardButton,
    ChatMemberUpdated,
)

# ================== CONFIG ==================
BOT_TOKEN = ""  # <--- put your token here
GAME_URL      = "https://pumpinglegs.github.io/pumpinglegs-web./tap.html"
LOGO_URL      = "https://raw.githubusercontent.com/pumpinglegs/pumpinglegs-web./refs/heads/main/logo.png"
COOLDOWN_SEC  = 3600  # 1 hour per user+group+coin
DB_FILE       = "legs.db"

# Your trending channel (must have set the bot as an admin of the channel)
TRENDING_CHAT = "-1003098054785"  # @PumpingLegsTrending
# ============================================

logging.basicConfig(level=logging.DEBUG)
bot = Bot(BOT_TOKEN)
dp = Dispatcher()

# ---- Day boundary helper (UTC, no timezone issues) ----
def day_midnight_epoch_utc() -> int:
    """Unix timestamp for today's 00:00 UTC."""
    return int(time.time() // 86400 * 86400)

# --------- DB INIT ----------
async def init_db():
    async with aiosqlite.connect(DB_FILE) as db:
        # core tables
        await db.execute("""
        CREATE TABLE IF NOT EXISTS runs (
            user_id INTEGER,
            chat_id INTEGER,
            coin_id TEXT,
            taps INTEGER,
            ts INTEGER
        )
        """)
        await db.execute("""
        CREATE TABLE IF NOT EXISTS group_coins (
            chat_id INTEGER PRIMARY KEY,
            coin_id TEXT
        )
        """)
        await db.execute("""
        CREATE TABLE IF NOT EXISTS group_settings (
            chat_id INTEGER PRIMARY KEY,
            echo_enabled INTEGER DEFAULT 1
        )
        """)
        # live scoreboard message per group
        await db.execute("""
        CREATE TABLE IF NOT EXISTS group_live (
            chat_id INTEGER PRIMARY KEY,
            message_id INTEGER
        )
        """)
        # global coin registry (for market cap lookups)
        await db.execute("""
        CREATE TABLE IF NOT EXISTS coin_registry (
            coin_id TEXT PRIMARY KEY,
            chain   TEXT,
            address TEXT,
            symbol  TEXT
        )
        """)
        # top-5 one-time announcements per day
        await db.execute("""
        CREATE TABLE IF NOT EXISTS top5_hits (
            day_key TEXT,
            coin_id TEXT,
            PRIMARY KEY (day_key, coin_id)
        )
        """)
        # NEW: one persistent leaderboard message in the trending channel
        await db.execute("""
        CREATE TABLE IF NOT EXISTS trending_live (
            id INTEGER PRIMARY KEY CHECK (id = 1),
            message_id INTEGER
        )
        """)

        # helpful indexes
        await db.execute("CREATE INDEX IF NOT EXISTS idx_runs_time ON runs(ts)")
        await db.execute("CREATE INDEX IF NOT EXISTS idx_runs_user_coin ON runs(user_id, coin_id, ts)")
        await db.execute("CREATE INDEX IF NOT EXISTS idx_runs_user_chat_coin_ts ON runs(user_id, chat_id, coin_id, ts)")
        await db.execute("CREATE INDEX IF NOT EXISTS idx_runs_coin_ts ON runs(coin_id, ts)")
        await db.commit()

# --------- HELPERS ----------
def fmt_compact(n: int) -> str:
    if n >= 1_000_000: return f"{n/1_000_000:.2f}M".rstrip('0').rstrip('.')
    if n >= 1_000:     return f"{n/1_000:.2f}K".rstrip('0').rstrip('.')
    return str(n)

def fmt_money(n: float | int | None) -> str:
    if not n or n <= 0: return "N/A"
    n = float(n)
    if n >= 1_000_000_000: return f"${n/1_000_000_000:.2f}B".rstrip('0').rstrip('.')
    if n >= 1_000_000:     return f"${n/1_000_000:.2f}M".rstrip('0').rstrip('.')
    if n >= 1_000:         return f"${n/1_000:.2f}K".rstrip('0').rstrip('.')
    return f"${int(n)}"

def medal_for(i: int) -> str:
    return ["🥇", "🥈", "🥉", "🐆", "🐆"][i] if i < 5 else ""

async def get_group_coin(chat_id: int) -> str | None:
    async with aiosqlite.connect(DB_FILE) as db:
        async with db.execute("SELECT coin_id FROM group_coins WHERE chat_id=?", (chat_id,)) as cur:
            row = await cur.fetchone()
            return row[0] if row else None

async def get_echo_enabled(chat_id: int) -> bool:
    async with aiosqlite.connect(DB_FILE) as db:
        async with db.execute("SELECT echo_enabled FROM group_settings WHERE chat_id=?", (chat_id,)) as cur:
            row = await cur.fetchone()
            return bool(row[0]) if row else True

async def set_echo_enabled(chat_id: int, enabled: bool):
    async with aiosqlite.connect(DB_FILE) as db:
        await db.execute(
            "REPLACE INTO group_settings (chat_id, echo_enabled) VALUES (?, ?)",
            (chat_id, 1 if enabled else 0)
        )
        await db.commit()

# ---- cooldown per user + group + coin
async def last_run_ts(user_id: int, chat_id: int, coin_id: str) -> int | None:
    async with aiosqlite.connect(DB_FILE) as db:
        async with db.execute(
            "SELECT ts FROM runs WHERE user_id=? AND chat_id=? AND coin_id=? ORDER BY ts DESC LIMIT 1",
            (user_id, chat_id, coin_id)
        ) as cur:
            row = await cur.fetchone()
            return row[0] if row else None

async def can_run_now(user_id: int, chat_id: int, coin_id: str) -> tuple[bool, int]:
    lr = await last_run_ts(user_id, chat_id, coin_id)
    now = int(time.time())
    if lr is None or now - lr >= COOLDOWN_SEC:
        return True, 0
    remaining = COOLDOWN_SEC - (now - lr)
    return False, remaining

def cooldown_msg(seconds: int) -> str:
    mins = max(1, seconds // 60)
    return f"🧊 Cool your legs, tireless runner! You have <b>{mins} minute(s)</b> left until next run."

def sprint_kb(url: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        inline_keyboard=[[InlineKeyboardButton(text="LETS RUN 🏃‍♂️", web_app=WebAppInfo(url=url))]]
    )

def dm_deeplink_kb(coin: str, chat_id: int | None = None) -> InlineKeyboardMarkup:
    if hasattr(bot, "_me"): botname = bot._me.username
    else:                   botname = "PumpingLegsBot"
    start_param = f"sprint_{coin}" + (f"_{chat_id}" if chat_id else "")
    deep = f"https://t.me/{botname}?start={start_param}"
    return InlineKeyboardMarkup(
        inline_keyboard=[[InlineKeyboardButton(text="LETS RUN 🏃‍♂️", url=deep)]]
    )

# live message helpers (per group)
async def get_live_msg_id(chat_id: int) -> int | None:
    async with aiosqlite.connect(DB_FILE) as db:
        async with db.execute("SELECT message_id FROM group_live WHERE chat_id=?", (chat_id,)) as cur:
            row = await cur.fetchone()
            return row[0] if row else None

async def set_live_msg_id(chat_id: int, msg_id: int):
    async with aiosqlite.connect(DB_FILE) as db:
        await db.execute("REPLACE INTO group_live (chat_id, message_id) VALUES (?, ?)", (chat_id, msg_id))
        await db.commit()

# trending channel live message helpers
async def get_trending_msg_id() -> int | None:
    async with aiosqlite.connect(DB_FILE) as db:
        async with db.execute("SELECT message_id FROM trending_live WHERE id=1") as cur:
            row = await cur.fetchone()
            return row[0] if row else None

async def set_trending_msg_id(msg_id: int):
    async with aiosqlite.connect(DB_FILE) as db:
        await db.execute("REPLACE INTO trending_live (id, message_id) VALUES (1, ?)", (msg_id,))
        await db.commit()

async def coin_total_today(coin_id: str) -> int:
    start_ts = day_midnight_epoch_utc()
    async with aiosqlite.connect(DB_FILE) as db:
        async with db.execute(
            "SELECT COALESCE(SUM(taps),0) FROM runs WHERE ts >= ? AND coin_id=?",
            (start_ts, coin_id)
        ) as cur:
            row = await cur.fetchone()
            return int(row[0] or 0)

# ---------- Coin registry (global) ----------
async def set_contract(coin_id: str, chain: str, address: str, symbol: str):
    coin_id = coin_id.upper()
    async with aiosqlite.connect(DB_FILE) as db:
        await db.execute("""
        INSERT INTO coin_registry (coin_id, chain, address, symbol)
        VALUES (?, ?, ?, ?)
        ON CONFLICT(coin_id) DO UPDATE SET chain=excluded.chain, address=excluded.address, symbol=excluded.symbol
        """, (coin_id, chain.lower(), address, symbol.upper()))
        await db.commit()

async def get_contract(coin_id: str):
    coin_id = coin_id.upper()
    async with aiosqlite.connect(DB_FILE) as db:
        async with db.execute("SELECT chain, address, symbol FROM coin_registry WHERE coin_id=?", (coin_id,)) as cur:
            row = await cur.fetchone()
            if row:
                return {"chain": row[0], "address": row[1], "symbol": row[2]}
            return None

# ---------- Dexscreener (cached) ----------
_dex_cache = {}  # key: address -> (fdv, ts)
DEX_CACHE_SECONDS = 300

async def dexscreener_fdv_by_address(address: str) -> float | None:
    now = time.time()
    if address in _dex_cache:
        fdv, ts = _dex_cache[address]
        if now - ts < DEX_CACHE_SECONDS:
            return fdv

    url = f"https://api.dexscreener.com/latest/dex/tokens/{address}"
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(url, timeout=10) as resp:
                if resp.status != 200:
                    return None
                data = await resp.json()
    except Exception:
        return None

    pairs = data.get("pairs") or []
    if not pairs:
        _dex_cache[address] = (None, now)
        return None

    def liq(p):
        try:
            return float(p.get("liquidity", {}).get("usd", 0)) or 0.0
        except Exception:
            return 0.0

    best = max(pairs, key=liq)
    fdv = best.get("fdv")
    try:
        fdv = float(fdv) if fdv is not None else None
    except Exception:
        fdv = None

    _dex_cache[address] = (fdv, now)
    return fdv

# ---------- Top-5 breakthrough tracking (UTC day key) ----------
def utc_day_key() -> str:
    return time.strftime("%Y-%m-%d", time.gmtime())

async def already_announced_today(coin_id: str) -> bool:
    day = utc_day_key()
    async with aiosqlite.connect(DB_FILE) as db:
        async with db.execute("SELECT 1 FROM top5_hits WHERE day_key=? AND coin_id=?", (day, coin_id)) as cur:
            return (await cur.fetchone()) is not None

async def mark_announced_today(coin_id: str):
    day = utc_day_key()
    async with aiosqlite.connect(DB_FILE) as db:
        await db.execute("INSERT OR IGNORE INTO top5_hits (day_key, coin_id) VALUES (?, ?)", (day, coin_id))
        await db.commit()

async def todays_top5() -> list[tuple[str, int]]:
    start_ts = day_midnight_epoch_utc()
    async with aiosqlite.connect(DB_FILE) as db:
        async with db.execute("""
            SELECT coin_id, SUM(taps) AS total
            FROM runs
            WHERE ts >= ?
            GROUP BY coin_id
            ORDER BY total DESC
            LIMIT 5
        """, (start_ts,)) as cur:
            rows = await cur.fetchall()
            logging.debug("Top 5 coins: %s", rows)
            return [(r[0], int(r[1])) for r in rows]

async def maybe_announce_top5_breakthrough(coin_id: str):
    top5 = await todays_top5()
    logging.debug("Top 5 check for %s -> %s", coin_id, top5)
    in_top5 = any(c == coin_id for c, _ in top5)
    if not in_top5:
        return
    if await already_announced_today(coin_id):
        logging.debug("Coin %s already announced today", coin_id)
        return

    reg = await get_contract(coin_id)
    mcap = None
    sym = coin_id
    if reg:
        sym = reg.get("symbol") or coin_id
        addr = reg.get("address")
        mcap = await dexscreener_fdv_by_address(addr) if addr else None

    total_today = next((t for c, t in top5 if c == coin_id), 0)

    text = (
        f"🥳 <b>{sym}</b> just sprinted into the <u>TOP 5</u>! 🚀🔥\n"
        f"💰 Market Cap: {fmt_money(mcap)}\n"
        f"🏃 Current Score: <b>{fmt_compact(total_today)}</b> steps\n"
        f"Keep running to climb higher!"
    )
    try:
        await bot.send_message(TRENDING_CHAT, text, parse_mode="HTML")
        await mark_announced_today(coin_id)
    except Exception as e:
        logging.error("Failed to post to TRENDING_CHAT: %s, chat_id: %s", e, TRENDING_CHAT)

# ---------- Trending Channel Leaderboard (live single message) ----------
async def build_leaderboard_text() -> str:
    start_ts = day_midnight_epoch_utc()
    async with aiosqlite.connect(DB_FILE) as db:
        async with db.execute("""
            SELECT coin_id, SUM(taps) AS total, COUNT(*) as runs
            FROM runs
            WHERE ts >= ?
            GROUP BY coin_id
            ORDER BY total DESC
            LIMIT 15
        """, (start_ts,)) as cur:
            rows = await cur.fetchall()

    if not rows:
        return "🏆 <b>PumpingLegs — Today (Trending Top 15)</b>\n\n📉 No runs yet today..."

    lines = ["🏆 <b>PumpingLegs — Today (Trending Top 15)</b>"]
    for idx, (coin, total, runs) in enumerate(rows, start=1):
        icon = medal_for(idx-1)
        total_s = fmt_compact(int(total))
        if idx <= 5:
            lines.append(f"{icon} <b>{coin}</b> | {total_s} | {runs} 🏃‍♂️")
        else:
            lines.append(f"{idx}. {coin} | {total_s} | {runs} 🏃‍♂️")
    return "\n".join(lines)

async def update_trending_leaderboard():
    text = await build_leaderboard_text()
    msg_id = await get_trending_msg_id()
    try:
        if msg_id:
            try:
                await bot.edit_message_text(
                    chat_id=TRENDING_CHAT,
                    message_id=msg_id,
                    text=text,
                    parse_mode="HTML"
                )
                logging.debug("Trending leaderboard edited (msg_id=%s).", msg_id)
                return
            except Exception as e:
                logging.warning("Trending edit failed, sending new: %s", e)
        sent = await bot.send_message(TRENDING_CHAT, text, parse_mode="HTML")
        await set_trending_msg_id(sent.message_id)
        logging.debug("Trending leaderboard sent (msg_id=%s).", sent.message_id)
    except Exception as e:
        logging.error("Failed to update trending leaderboard: %s", e)

# --------- BOT ADDED TO GROUP (Welcome) ----------
@dp.my_chat_member(F.chat.type.in_({"group", "supergroup"}))
async def on_added_to_group(ev: ChatMemberUpdated):
    if ev.new_chat_member.status in {"member", "administrator"}:
        await set_echo_enabled(ev.chat.id, True)

        url = f"{GAME_URL}?coin_id=DEMO&gid={ev.chat.id}"
        kb = sprint_kb(url)

        caption = (
            "👋 Thanks for adding me!\n\n"
            "<b>PumpingLegs</b> 🦵 is ready here.\n\n"
            "📌 What you can do:\n"
            "• /setcoin <code>COIN</code> — bind a coin to this group\n"
            "• /sprint — run the 5-second sprint for your coin\n"
            "• /leaderboard — see today’s Top 15 coins (resets daily)\n"
            "• /echo_off — mute group result messages\n\n"
            "🔥 LET’S RUN 🏃‍♂️"
        )

        try:
            await bot.send_photo(ev.chat.id, LOGO_URL, caption=caption, parse_mode="HTML", reply_markup=kb)
        except Exception:
            await bot.send_message(ev.chat.id, caption, parse_mode="HTML", reply_markup=kb)
        logging.debug("Welcome message sent to group %s", ev.chat.id)

# --------- /start ----------
@dp.message(Command("start"))
async def cmd_start(m: types.Message):
    args = (m.text or "").split(maxsplit=1)
    coin = None
    gid = None

    # supports: /start sprint_COIN  or  /start sprint_COIN_CHATID
    if len(args) == 2 and args[1].lower().startswith("sprint_"):
        parts = args[1].split("_", 2)  # ["sprint", "COIN", "CHATID?"]
        if len(parts) >= 2:
            coin = parts[1].upper()
        if len(parts) == 3:
            try:
                gid = int(parts[2])
            except Exception:
                gid = None

    if coin and gid:
        url = f"{GAME_URL}?coin_id={coin}&gid={gid}"
    elif coin:
        url = f"{GAME_URL}?coin_id={coin}"
    else:
        url = GAME_URL

    kb = sprint_kb(url)
    caption = (
        "Welcome to <b>PumpingLegs</b> 🦵\n"
        "• /sprint – play the 5s tap sprint\n"
        "• /leaderboard – today’s Top 15 coins\n"
        "• /ping – check bot is alive\n\n"
        "<b>Group admins</b>:\n"
        "• /setcoin <code>COIN</code>\n"
        "• /coin, /clearcoin, /echo_on, /echo_off\n\n"
        "🔥 LET’S RUN 🏃‍♂️"
    )
    try:
        await m.answer_photo(LOGO_URL, caption=caption, parse_mode="HTML", reply_markup=kb)
    except Exception:
        await m.answer(caption, parse_mode="HTML", reply_markup=kb)

# --------- BASIC COMMANDS ----------
@dp.message(Command("ping"))
async def cmd_ping(m: types.Message):
    await m.answer("pong ✅")

@dp.message(Command("posttest"))
async def cmd_posttest(m: types.Message):
    try:
        await bot.send_message(TRENDING_CHAT, "✅ Channel post test from bot.")
        await m.answer("Sent a test message to the trending channel.")
    except Exception as e:
        await m.answer(f"Failed to post to channel: {e}")

# Manual refresh of channel leaderboard (DM only, useful for testing)
@dp.message(Command("forceboard"))
async def cmd_forceboard(m: types.Message):
    if m.chat.type != "private":
        return await m.answer("Run this in DM.")
    await update_trending_leaderboard()
    await m.answer("Trending leaderboard refreshed.")

# /sprint (group-safe with gid + DM fallback)
@dp.message(Command("sprint"))
async def cmd_sprint(m: types.Message):
    coin = "DEMO"
    if m.chat.type in ("group", "supergroup"):
        gcoin = await get_group_coin(m.chat.id)
        if gcoin:
            coin = gcoin

    if m.chat and m.chat.type in ("group", "supergroup"):
        url = f"{GAME_URL}?coin_id={coin}&gid={m.chat.id}"

        if hasattr(bot, "_me"):
            botname = bot._me.username
        else:
            botname = "PumpingLegsBot"
        deep = f"https://t.me/{botname}?start=sprint_{coin}_{m.chat.id}"

        kb = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="LETS RUN 🏃‍♂️", web_app=WebAppInfo(url=url))],
            [InlineKeyboardButton(text="LETS RUN (DM) 🏃‍♂️", url=deep)]
        ])

        try:
            await m.answer("LET'S SEE HOW FAST YOU CAN RUN!", reply_markup=kb)
        except Exception as e:
            logging.warning("Group WebApp button failed: %r", e)
            kb_dm = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="LETS RUN (DM) 🏃‍♂️", url=deep)]
            ])
            await m.answer("This group doesn’t allow the WebApp button. Use the DM link:", reply_markup=kb_dm)
        return

    # DM
    url = f"{GAME_URL}?coin_id={coin}"
    await m.answer("LET'S SEE HOW FAST YOU CAN RUN!", reply_markup=sprint_kb(url))

@dp.message(Command("setcoin"))
async def cmd_setcoin(m: types.Message):
    if m.chat.type not in ("group", "supergroup"):
        return await m.answer("⚠️ Use this in a group.")
    parts = (m.text or "").split(maxsplit=1)
    if len(parts) < 2:
        return await m.answer("Usage: /setcoin <COIN>")
    coin = parts[1].upper()
    async with aiosqlite.connect(DB_FILE) as db:
        await db.execute(
            "REPLACE INTO group_coins (chat_id, coin_id) VALUES (?, ?)",
            (m.chat.id, coin)
        )
        await db.commit()
    await m.answer(f"✅ This group now boosts <b>{coin}</b>", parse_mode="HTML")

@dp.message(Command("coin"))
async def cmd_coin(m: types.Message):
    if m.chat.type not in ("group", "supergroup"):
        return await m.answer("⚠️ Use this in a group.")
    coin = await get_group_coin(m.chat.id)
    if coin:
        await m.answer(f"🔗 This group boosts <b>{coin}</b>", parse_mode="HTML")
    else:
        await m.answer("❌ No coin bound. Use /setcoin <COIN>")

@dp.message(Command("clearcoin"))
async def cmd_clearcoin(m: types.Message):
    if m.chat.type not in ("group", "supergroup"):
        return await m.answer("⚠️ Use this in a group.")
    async with aiosqlite.connect(DB_FILE) as db:
        await db.execute("DELETE FROM group_coins WHERE chat_id=?", (m.chat.id,))
        await db.commit()
    await m.answer("🗑️ Coin binding cleared.")

@dp.message(Command("echo_on"))
async def cmd_echo_on(m: types.Message):
    if m.chat.type not in ("group", "supergroup"):
        return await m.answer("⚠️ Use this in a group.")
    await set_echo_enabled(m.chat.id, True)
    await m.answer("🔊 Result echo is now <b>ON</b>.", parse_mode="HTML")

@dp.message(Command("echo_off"))
async def cmd_echo_off(m: types.Message):
    if m.chat.type not in ("group", "supergroup"):
        return await m.answer("⚠️ Use this in a group.")
    await set_echo_enabled(m.chat.id, False)
    await m.answer("🔇 Result echo is now <b>OFF</b>.", parse_mode="HTML")

# Register contract for a coin (one-time, any admin)
@dp.message(Command("setcontract"))
async def cmd_setcontract(m: types.Message):
    # Usage: /setcontract COIN CHAIN TOKEN_ADDRESS SYMBOL
    parts = (m.text or "").split()
    if len(parts) < 5:
        return await m.answer("Usage: /setcontract <COIN> <CHAIN> <TOKEN_ADDRESS> <SYMBOL>")
    coin, chain, address, symbol = parts[1].upper(), parts[2].lower(), parts[3], parts[4].upper()
    await set_contract(coin, chain, address, symbol)
    await m.answer(f"✅ Registered contract for <b>{coin}</b> on <b>{chain}</b>.", parse_mode="HTML")

# --------- RECEIVE RESULTS ----------
@dp.message(F.web_app_data)
async def receive_data(m: types.Message):
    logging.debug("🔍 Received message type: %s", type(m).__name__)
    if not getattr(m, "web_app_data", None):
        logging.debug("❌ No WebApp data in message")
        return

    try:
        data = json.loads(m.web_app_data.data)
        logging.debug(
            "WEBAPP RESULT: user=%s coin=%s gid=%s taps=%s chat=%s",
            m.from_user.id, data.get("coin_id"), data.get("gid"), data.get("taps"),
            (m.chat.type if m.chat else None)
        )
        taps = int(data.get("taps", 0))
        coin_id = (data.get("coin_id") or "DEMO").upper()
        gid_raw = data.get("gid")
        target_chat_id = None
        try:
            if gid_raw is not None:
                target_chat_id = int(str(gid_raw))
        except Exception as e:
            logging.error("Invalid gid: %s, raw: %s", e, gid_raw)

        now = int(time.time())

        # binding override by group
        if target_chat_id:
            gcoin = await get_group_coin(target_chat_id)
            if gcoin:
                coin_id = gcoin
        elif m.chat and m.chat.type in ("group", "supergroup"):
            gcoin = await get_group_coin(m.chat.id)
            if gcoin:
                coin_id = gcoin

        # effective chat for cooldown and storage
        effective_chat_id = target_chat_id if target_chat_id else (m.chat.id if m.chat else 0)

        # ---- COOLDOWN per user + group + coin
        allowed, remaining = await can_run_now(m.from_user.id, effective_chat_id, coin_id)
        if not allowed:
            return await m.answer(cooldown_msg(remaining), parse_mode="HTML")

        # ---- STORE RUN
        async with aiosqlite.connect(DB_FILE) as db:
            await db.execute(
                "INSERT INTO runs (user_id, chat_id, coin_id, taps, ts) VALUES (?, ?, ?, ?, ?)",
                (m.from_user.id, effective_chat_id, coin_id, taps, now)
            )
            await db.commit()
        logging.debug("Test score stored: user=%s, chat=%s, coin=%s, taps=%s",
                      m.from_user.id, effective_chat_id, coin_id, taps)

        await m.answer(f"🏃 You tapped <b>{taps}</b> for <b>{coin_id}</b>!", parse_mode="HTML")

        # Post every score to TRENDING_CHAT (optional)
        try:
            total_today = await coin_total_today(coin_id)
            name = (m.from_user.full_name or "User").replace("<", "&lt;").replace(">", "&gt;")
            text = (
                f"🏁 <b>{name}</b> ran <b>{taps}</b> for <b>{coin_id}</b>!\n"
                f"📊 <b>{coin_id}</b> total today: <b>{fmt_compact(total_today)}</b> 🏃‍♂️"
            )
            await bot.send_message(TRENDING_CHAT, text, parse_mode="HTML")
            logging.debug("Posted to TRENDING_CHAT: %s", text)
        except Exception as e:
            logging.error("Failed to post to TRENDING_CHAT: %s, chat_id: %s", e, TRENDING_CHAT)

        # ALWAYS-ON live scoreboard message in the originating group
        if target_chat_id:
            post_chat = target_chat_id
        elif m.chat and m.chat.type in ("group", "supergroup"):
            post_chat = m.chat.id
        else:
            post_chat = None

        if post_chat:
            total_today = await coin_total_today(coin_id)
            name = (m.from_user.full_name or "User").replace("<", "&lt;").replace(">", "&gt;")
            text = (
                f"🏁 <b>{name}</b> ran <b>{taps}</b> for <b>{coin_id}</b>!\n"
                f"📊 <b>{coin_id}</b> total today: <b>{fmt_compact(total_today)}</b> 🏃‍♂️"
            )
            live_id = await get_live_msg_id(post_chat)
            try:
                if live_id:
                    await m.bot.edit_message_text(
                        chat_id=post_chat,
                        message_id=live_id,
                        text=text,
                        parse_mode="HTML"
                    )
                else:
                    raise Exception("no live msg")
            except Exception:
                sent = await m.bot.send_message(post_chat, text, parse_mode="HTML")
                await set_live_msg_id(post_chat, sent.message_id)

        # Update the channel leaderboard message (this is the missing link!)
        await update_trending_leaderboard()

        # Top-5 breakthrough (UTC day)
        await maybe_announce_top5_breakthrough(coin_id)

    except Exception as e:
        logging.error("Error in receive_data: %s, data: %s", e, getattr(m, "web_app_data", None))
        await m.answer("⚠️ Error processing result: " + str(e))

# --------- LEADERBOARD (Today, UTC) ----------
@dp.message(Command("leaderboard"))
async def cmd_leaderboard(m: types.Message):
    # This replies wherever the command is used (DM or group). Channels can’t run commands.
    text = await build_leaderboard_text()
    await m.answer(text, parse_mode="HTML")

# --------- MAIN ----------
async def main():
    await init_db()
    try:
        me = await bot.get_me()
        bot._me = me
        logging.info("Bot initialized: @%s", me.username)
    except Exception:
        pass
    logging.info("Starting PumpingLegs bot...")
    await dp.start_polling(bot, allowed_updates=dp.resolve_used_update_types())

if __name__ == "__main__":
    asyncio.run(main())
